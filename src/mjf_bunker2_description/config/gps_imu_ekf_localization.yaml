### ekf global config file ###
namespace/ekf_global_filter_node:
    ros__parameters:
        frequency: 30.0
        two_d_mode: true

        transform_time_offset: 0.0
        transform_timeout: 0.0
        
        print_diagnostics: true
        debug: false
        
        # 1. Set the map_frame, odom_frame, and base_link frames to the appropriate frame names for your system.
        #     1a. If your system does not have a map_frame, just remove it, and make sure "world_frame" is set to the value of odom_frame.
        # 2. If you are fusing continuous position data such as wheel encoder odom, visual odom, or IMU data, set "world_frame" to your odom_frame value. This is the default behavior for robot_localization's state estimation nodes.
        # 3. If you are fusing global absolute position data that is subject to discrete jumps (e.g., GPS or position updates from landmark observations) then:
        #     3a. Set your "world_frame" to your map_frame value
        #     3b. MAKE SURE something else is generating the odom->base_link transform. Note that this can even be another state estimation node from robot_localization! However, that instance should *not* fuse the global data.
        map_frame: map              # Defaults to "map" if unspecified
        odom_frame: odom            # Defaults to "odom" if unspecified
        base_link_frame: base_link  # Defaults to "base_link" if unspecified
        world_frame: map            # Defaults to the value of odom_frame if unspecified
        
        odom0: odom
        odom0_config: [false, false,  false,  # X,     Y,      Z
                       false, false,  false,  # roll,  pitch,  yaw
                        true,  true,  false,  # dX,    dY,     dZ
                       false, false,   true,  # droll, dpitch, dyaw
                       false, false,  false ] # ddX,   ddY,    ddZ
        odom0_differential: false

        odom1: odom/gps
        odom1_config: [ true,  true,  false,
                       false, false,  false,
                       false, false,  false,
                       false, false,  false,
                       false, false,  false ]
        odom1_differential: false

        imu0: imu
        imu0_config: [ false, false, false,  # X,     Y,      Z
                       false, false,  true,  # roll,  pitch,  yaw
                       false, false, false,  # dX,    dY,     dZ
                       false, false,  true,  # droll, dpitch, dyaw
                        true,  true, false ] # ddX,   ddY,    ddZ
        imu0_differential: false
        imu0_remove_gravitational_acceleration: true

        initial_estimate_covariance: [1.0e-9,    0.0,   0.0,   0.0,   0.0,    0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,
                                         0.0, 1.0e-9,   0.0,   0.0,   0.0,    0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,
                                         0.0,    0.0,   1.0,   0.0,   0.0,    0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,
                                         0.0,    0.0,   0.0,   1.0,   0.0,    0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,
                                         0.0,    0.0,   0.0,   0.0,   1.0,    0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,
                                         0.0,    0.0,   0.0,   0.0,   0.0,    1.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,
                                         0.0,    0.0,   0.0,   0.0,   0.0,    0.0,   1.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,
                                         0.0,    0.0,   0.0,   0.0,   0.0,    0.0,   0.0,   1.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,
                                         0.0,    0.0,   0.0,   0.0,   0.0,    0.0,   0.0,   0.0,   1.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,
                                         0.0,    0.0,   0.0,   0.0,   0.0,    0.0,   0.0,   0.0,   0.0,   1.0,   0.0,   0.0,   0.0,   0.0,   0.0,
                                         0.0,    0.0,   0.0,   0.0,   0.0,    0.0,   0.0,   0.0,   0.0,   0.0,   1.0,   0.0,   0.0,   0.0,   0.0,
                                         0.0,    0.0,   0.0,   0.0,   0.0,    0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   1.0,   0.0,   0.0,   0.0,
                                         0.0,    0.0,   0.0,   0.0,   0.0,    0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   1.0,   0.0,   0.0,
                                         0.0,    0.0,   0.0,   0.0,   0.0,    0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   1.0,   0.0,
                                         0.0,    0.0,   0.0,   0.0,   0.0,    0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   0.0,   1.0]


### ekf local config file ###
namespace/ekf_local_filter_node:
    ros__parameters:
        frequency: 30.0
        two_d_mode: true

        transform_time_offset: 0.0
        transform_timeout: 0.0
        
        print_diagnostics: true
        debug: false
        
        # 1. Set the map_frame, odom_frame, and base_link frames to the appropriate frame names for your system.
        #     1a. If your system does not have a map_frame, just remove it, and make sure "world_frame" is set to the value of odom_frame.
        # 2. If you are fusing continuous position data such as wheel encoder odom, visual odom, or IMU data, set "world_frame" to your odom_frame value. This is the default behavior for robot_localization's state estimation nodes.
        # 3. If you are fusing global absolute position data that is subject to discrete jumps (e.g., GPS or position updates from landmark observations) then:
        #     3a. Set your "world_frame" to your map_frame value
        #     3b. MAKE SURE something else is generating the odom->base_link transform. Note that this can even be another state estimation node from robot_localization! However, that instance should *not* fuse the global data.
        map_frame: map              # Defaults to "map" if unspecified
        odom_frame: odom            # Defaults to "odom" if unspecified
        base_link_frame: base_link  # Defaults to "base_link" if unspecified
        world_frame: odom           # Defaults to the value of odom_frame if unspecified
        
        odom0: odom
        odom0_config: [ true,  true,  false,  # X,     Y,      Z
                       false, false,  false,  # roll,  pitch,  yaw
                        true,  true,  false,  # dX,    dY,     dZ
                       false, false,   true,  # droll, dpitch, dyaw
                       false, false,  false ] # ddX,   ddY,    ddZ
        odom0_differential: false

        imu0: imu
        imu0_config: [ false, false, false,  # X,     Y,      Z
                       false, false,  true,  # roll,  pitch,  yaw
                       false, false, false,  # dX,    dY,     dZ
                       false, false,  true,  # droll, dpitch, dyaw
                        true,  true, false ] # ddX,   ddY,    ddZ
        imu0_differential: false
        imu0_remove_gravitational_acceleration: true


### navsat transform node config file ###
namespace/navsat_transform_node:
    ros__parameters:
        # The real-valued frequency, in Hz, at which navsat_transform_node checks for new sensor_msgs/NavSatFix messages, and publishes filtered sensor_msgs/NavSatFix when publish_filtered_gps is set to true.
        frequency: 5.0

        # Enter the magnetic declination for your location. If you don’t know it, see http://www.ngdc.noaa.gov/geomag-web (make sure to convert the value to radians). This parameter is needed if your IMU provides its orientation with respect to the magnetic north.
        magnetic_declination_radians: 0.064746945898778

        # Your IMU should read 0 for yaw when facing east. If it doesn’t, enter the offset here (desired_value = offset + sensor_raw_value). For example, if your IMU reports 0 when facing north, as most of them do, this parameter would be pi/2 (~1.5707963). This parameter changed in version 2.2.1. Previously, navsat_transform_node assumed that IMUs read 0 when facing north, so yaw_offset was used acordingly.
        yaw_offset: -0.38

        # If true, navsat_transform_node will wait to get a datum from either: the datum parameter or the set_datum service
        wait_for_datum: false
        
        use_odometry_yaw: false

        # The time, in seconds, to wait before calculating the transform from GPS coordinates to your robot’s world frame.
        delay: 5.0

        # Instead of using the first GPS location and IMU-based heading for the local-frame origin, users can specify the origin (datum) using this parameter. The fields in the parameter represent latitude and longitude in decimal degrees, and heading in radians. As navsat_transform_node assumes an ENU standard, a 0 heading corresponds to east.
        # datum: [45.1463732, 10.0019396, 2.618]

        publish_filtered_gps: true

